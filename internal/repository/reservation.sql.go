// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: reservation.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelReservation = `-- name: CancelReservation :exec
UPDATE reservations
SET reservation_status = 'cancelled', updated_at = NOW()
WHERE id = $1 AND reservation_status = 'pending'
`

func (q *Queries) CancelReservation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, cancelReservation, id)
	return err
}

const checkSeatAvailability = `-- name: CheckSeatAvailability :one
SELECT COUNT(*) FROM reservations 
WHERE schedule_id = $1 AND wagon_id = $2 AND seat_id = $3
  AND reservation_status IN ('pending', 'success')
`

type CheckSeatAvailabilityParams struct {
	ScheduleID int64 `db:"schedule_id" json:"schedule_id"`
	WagonID    int64 `db:"wagon_id" json:"wagon_id"`
	SeatID     int64 `db:"seat_id" json:"seat_id"`
}

func (q *Queries) CheckSeatAvailability(ctx context.Context, arg CheckSeatAvailabilityParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkSeatAvailability, arg.ScheduleID, arg.WagonID, arg.SeatID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const confirmReservation = `-- name: ConfirmReservation :exec


UPDATE reservations
SET reservation_status = 'success', updated_at = NOW()
WHERE id = $1 AND reservation_status = 'pending'
`

// -- name: HoldSeat :exec
// INSERT INTO seat_holds (passenger_id, schedule_id, wagon_id, seat_id, expires_at)
// VALUES ($1, $2, $3, $4, NOW() + INTERVAL '15 minutes')
// RETURNING *;
// -- name: CreateReservationFromHold :one
// WITH deleted_hold AS (
//
//	DELETE FROM seat_holds
//	WHERE seat_holds.passenger_id = $1
//	AND seat_holds.schedule_id = $2
//	AND seat_holds.wagon_id = $3
//	AND seat_holds.seat_id = $4
//	RETURNING passenger_id, schedule_id, wagon_id, seat_id
//
// )
// INSERT INTO reservations (
//
//	id, passenger_id, schedule_id, wagon_id, seat_id, booking_date, reservation_status, discount_id, price, expires_at
//
// -- )
// SELECT
//
//	uuid_generate_v4(), deleted_hold.passenger_id, deleted_hold.schedule_id, deleted_hold.wagon_id, deleted_hold.seat_id,
//	NOW(), 'pending', $5, $6, NOW() + INTERVAL '15 minutes'
//
// FROM deleted_hold
// RETURNING *;
func (q *Queries) ConfirmReservation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, confirmReservation, id)
	return err
}

const countReservations = `-- name: CountReservations :one
select count(*) from reservations
`

func (q *Queries) CountReservations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countReservations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (
   passenger_id, schedule_id, wagon_id, seat_id, booking_date, reservation_status, discount_id, price, expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) 
RETURNING id, passenger_id, schedule_id, wagon_id, seat_id, booking_date, discount_id, price, reservation_status, expires_at, created_at, updated_at
`

type CreateReservationParams struct {
	PassengerID       uuid.UUID         `db:"passenger_id" json:"passenger_id"`
	ScheduleID        int64             `db:"schedule_id" json:"schedule_id"`
	WagonID           int64             `db:"wagon_id" json:"wagon_id"`
	SeatID            int64             `db:"seat_id" json:"seat_id"`
	BookingDate       pgtype.Timestamp  `db:"booking_date" json:"booking_date"`
	ReservationStatus StatusReservation `db:"reservation_status" json:"reservation_status"`
	DiscountID        pgtype.UUID       `db:"discount_id" json:"discount_id"`
	Price             *int64            `db:"price" json:"price"`
	ExpiresAt         pgtype.Timestamp  `db:"expires_at" json:"expires_at"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, createReservation,
		arg.PassengerID,
		arg.ScheduleID,
		arg.WagonID,
		arg.SeatID,
		arg.BookingDate,
		arg.ReservationStatus,
		arg.DiscountID,
		arg.Price,
		arg.ExpiresAt,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.PassengerID,
		&i.ScheduleID,
		&i.WagonID,
		&i.SeatID,
		&i.BookingDate,
		&i.DiscountID,
		&i.Price,
		&i.ReservationStatus,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReservation = `-- name: DeleteReservation :exec
DELETE FROM reservations
WHERE id = $1 AND reservation_status = 'canceled'
`

func (q *Queries) DeleteReservation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteReservation, id)
	return err
}

const expireUndpaidReservations = `-- name: ExpireUndpaidReservations :exec


DELETE FROM reservations
WHERE expires_at < NOW() AND reservation_status = 'pending'
`

// -- name: CleanupExpiredHolds :exec
// DELETE FROM seat_holds WHERE expires_at < NOW();
// -- name: ExpireSeatHolds :exec
// DELETE FROM seat_holds
// WHERE expires_at < NOW();
func (q *Queries) ExpireUndpaidReservations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, expireUndpaidReservations)
	return err
}

const getFullReservation = `-- name: GetFullReservation :one
SELECT 
r.id AS reservation_id,
p.name AS passenger_name,
p.id_number AS passenger_id_number,
u.name AS user_name,
u.email AS user_email,
s.departure_date,
s.arrival_date,
r.price AS ticket_price,
t.name AS train_name,
w.class_type,
w.wagon_number,
st.seat_number,
st.seat_row,
r.booking_date,
r.reservation_status,
rt.source_station,
rt.destination_station,
d.code AS discount_code,
d.discount_percent,
py.amount AS payment_amount,
py.payment_method,
py.payment_status 
FROM reservations r
LEFT JOIN passengers p ON r.passenger_id = p.id
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN schedules s ON r.schedule_id = s.id
LEFT JOIN seats st ON r.seat_id = st.id
LEFT JOIN wagons w ON r.wagon_id = w.id
LEFT JOIN trains t ON s.train_id = t.id
LEFT JOIN routes rt ON s.route_id = rt.id
LEFT JOIN discount_codes d ON r.discount_id = d.id
LEFT JOIN payments py ON r.id = py.reservation_id
WHERE r.id = $1
`

type GetFullReservationRow struct {
	ReservationID      uuid.UUID         `db:"reservation_id" json:"reservation_id"`
	PassengerName      *string           `db:"passenger_name" json:"passenger_name"`
	PassengerIDNumber  *string           `db:"passenger_id_number" json:"passenger_id_number"`
	UserName           *string           `db:"user_name" json:"user_name"`
	UserEmail          *string           `db:"user_email" json:"user_email"`
	DepartureDate      pgtype.Timestamp  `db:"departure_date" json:"departure_date"`
	ArrivalDate        pgtype.Timestamp  `db:"arrival_date" json:"arrival_date"`
	TicketPrice        *int64            `db:"ticket_price" json:"ticket_price"`
	TrainName          *string           `db:"train_name" json:"train_name"`
	ClassType          NullTipeClass     `db:"class_type" json:"class_type"`
	WagonNumber        *int32            `db:"wagon_number" json:"wagon_number"`
	SeatNumber         *int32            `db:"seat_number" json:"seat_number"`
	SeatRow            NullSeatRow       `db:"seat_row" json:"seat_row"`
	BookingDate        pgtype.Timestamp  `db:"booking_date" json:"booking_date"`
	ReservationStatus  StatusReservation `db:"reservation_status" json:"reservation_status"`
	SourceStation      *string           `db:"source_station" json:"source_station"`
	DestinationStation *string           `db:"destination_station" json:"destination_station"`
	DiscountCode       *string           `db:"discount_code" json:"discount_code"`
	DiscountPercent    *int32            `db:"discount_percent" json:"discount_percent"`
	PaymentAmount      *int64            `db:"payment_amount" json:"payment_amount"`
	PaymentMethod      *string           `db:"payment_method" json:"payment_method"`
	PaymentStatus      *string           `db:"payment_status" json:"payment_status"`
}

func (q *Queries) GetFullReservation(ctx context.Context, id uuid.UUID) (GetFullReservationRow, error) {
	row := q.db.QueryRow(ctx, getFullReservation, id)
	var i GetFullReservationRow
	err := row.Scan(
		&i.ReservationID,
		&i.PassengerName,
		&i.PassengerIDNumber,
		&i.UserName,
		&i.UserEmail,
		&i.DepartureDate,
		&i.ArrivalDate,
		&i.TicketPrice,
		&i.TrainName,
		&i.ClassType,
		&i.WagonNumber,
		&i.SeatNumber,
		&i.SeatRow,
		&i.BookingDate,
		&i.ReservationStatus,
		&i.SourceStation,
		&i.DestinationStation,
		&i.DiscountCode,
		&i.DiscountPercent,
		&i.PaymentAmount,
		&i.PaymentMethod,
		&i.PaymentStatus,
	)
	return i, err
}

const getReservation = `-- name: GetReservation :one
SELECT id, passenger_id, schedule_id, wagon_id, seat_id, booking_date, discount_id, price, reservation_status, expires_at, created_at, updated_at FROM reservations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetReservation(ctx context.Context, id uuid.UUID) (Reservation, error) {
	row := q.db.QueryRow(ctx, getReservation, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.PassengerID,
		&i.ScheduleID,
		&i.WagonID,
		&i.SeatID,
		&i.BookingDate,
		&i.DiscountID,
		&i.Price,
		&i.ReservationStatus,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listReservations = `-- name: ListReservations :many
SELECT 
r.id AS reservation_id,
p.name AS passenger_name,
p.id_number AS passenger_id_number,
u.name AS user_name,
u.email AS user_email,
s.departure_date,
s.arrival_date,
r.price AS ticket_price,
t.name AS train_name,
w.class_type,
w.wagon_number,
st.seat_number,
st.seat_row,
r.booking_date,
r.reservation_status,
rt.source_station,
rt.destination_station,
d.code AS discount_code,
d.discount_percent,
py.amount AS payment_amount,
py.payment_method,
py.payment_status
FROM reservations r
LEFT JOIN passengers p ON r.passenger_id = p.id
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN schedules s ON r.schedule_id = s.id
LEFT JOIN seats st ON r.seat_id = st.id
LEFT JOIN wagons w ON r.wagon_id = w.id
LEFT JOIN trains t ON s.train_id = t.id
LEFT JOIN routes rt ON s.route_id = rt.id
LEFT JOIN discount_codes d ON r.discount_id = d.id
LEFT JOIN payments py ON r.id = py.reservation_id
ORDER BY booking_date DESC
LIMIT $1
OFFSET $2
`

type ListReservationsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListReservationsRow struct {
	ReservationID      uuid.UUID         `db:"reservation_id" json:"reservation_id"`
	PassengerName      *string           `db:"passenger_name" json:"passenger_name"`
	PassengerIDNumber  *string           `db:"passenger_id_number" json:"passenger_id_number"`
	UserName           *string           `db:"user_name" json:"user_name"`
	UserEmail          *string           `db:"user_email" json:"user_email"`
	DepartureDate      pgtype.Timestamp  `db:"departure_date" json:"departure_date"`
	ArrivalDate        pgtype.Timestamp  `db:"arrival_date" json:"arrival_date"`
	TicketPrice        *int64            `db:"ticket_price" json:"ticket_price"`
	TrainName          *string           `db:"train_name" json:"train_name"`
	ClassType          NullTipeClass     `db:"class_type" json:"class_type"`
	WagonNumber        *int32            `db:"wagon_number" json:"wagon_number"`
	SeatNumber         *int32            `db:"seat_number" json:"seat_number"`
	SeatRow            NullSeatRow       `db:"seat_row" json:"seat_row"`
	BookingDate        pgtype.Timestamp  `db:"booking_date" json:"booking_date"`
	ReservationStatus  StatusReservation `db:"reservation_status" json:"reservation_status"`
	SourceStation      *string           `db:"source_station" json:"source_station"`
	DestinationStation *string           `db:"destination_station" json:"destination_station"`
	DiscountCode       *string           `db:"discount_code" json:"discount_code"`
	DiscountPercent    *int32            `db:"discount_percent" json:"discount_percent"`
	PaymentAmount      *int64            `db:"payment_amount" json:"payment_amount"`
	PaymentMethod      *string           `db:"payment_method" json:"payment_method"`
	PaymentStatus      *string           `db:"payment_status" json:"payment_status"`
}

func (q *Queries) ListReservations(ctx context.Context, arg ListReservationsParams) ([]ListReservationsRow, error) {
	rows, err := q.db.Query(ctx, listReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsRow{}
	for rows.Next() {
		var i ListReservationsRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.PassengerName,
			&i.PassengerIDNumber,
			&i.UserName,
			&i.UserEmail,
			&i.DepartureDate,
			&i.ArrivalDate,
			&i.TicketPrice,
			&i.TrainName,
			&i.ClassType,
			&i.WagonNumber,
			&i.SeatNumber,
			&i.SeatRow,
			&i.BookingDate,
			&i.ReservationStatus,
			&i.SourceStation,
			&i.DestinationStation,
			&i.DiscountCode,
			&i.DiscountPercent,
			&i.PaymentAmount,
			&i.PaymentMethod,
			&i.PaymentStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReservation = `-- name: UpdateReservation :exec
UPDATE reservations
  set  passenger_id = $2 , schedule_id = $3, wagon_id=$4, seat_id = $5, booking_date = $6, reservation_status = $7, discount_id = $8, price = $9, expires_at = $10, updated_at = NOW()
WHERE id = $1
`

type UpdateReservationParams struct {
	ID                uuid.UUID         `db:"id" json:"id"`
	PassengerID       uuid.UUID         `db:"passenger_id" json:"passenger_id"`
	ScheduleID        int64             `db:"schedule_id" json:"schedule_id"`
	WagonID           int64             `db:"wagon_id" json:"wagon_id"`
	SeatID            int64             `db:"seat_id" json:"seat_id"`
	BookingDate       pgtype.Timestamp  `db:"booking_date" json:"booking_date"`
	ReservationStatus StatusReservation `db:"reservation_status" json:"reservation_status"`
	DiscountID        pgtype.UUID       `db:"discount_id" json:"discount_id"`
	Price             *int64            `db:"price" json:"price"`
	ExpiresAt         pgtype.Timestamp  `db:"expires_at" json:"expires_at"`
}

func (q *Queries) UpdateReservation(ctx context.Context, arg UpdateReservationParams) error {
	_, err := q.db.Exec(ctx, updateReservation,
		arg.ID,
		arg.PassengerID,
		arg.ScheduleID,
		arg.WagonID,
		arg.SeatID,
		arg.BookingDate,
		arg.ReservationStatus,
		arg.DiscountID,
		arg.Price,
		arg.ExpiresAt,
	)
	return err
}

const updateTrainCapacity = `-- name: UpdateTrainCapacity :exec
UPDATE schedules
SET available_seats = available_seats - 1
WHERE id = $1 AND available_seats > 0
`

func (q *Queries) UpdateTrainCapacity(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateTrainCapacity, id)
	return err
}
